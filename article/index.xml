<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on ZhangXiaoshuai</title>
    <link>https://zhangxiaoshuai98.github.io/article/</link>
    <description>Recent content in Articles on ZhangXiaoshuai</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 03 Sep 2020 18:10:14 +0100</lastBuildDate>
    
	<atom:link href="https://zhangxiaoshuai98.github.io/article/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Redis学习2</title>
      <link>https://zhangxiaoshuai98.github.io/article/redislearn2/</link>
      <pubDate>Thu, 03 Sep 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/redislearn2/</guid>
      <description>Redis的多数据库、Redis的事务、Redis的数据持久化</description>
    </item>
    
    <item>
      <title>Redis学习1</title>
      <link>https://zhangxiaoshuai98.github.io/article/redislearn1/</link>
      <pubDate>Tue, 01 Sep 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/redislearn1/</guid>
      <description>对Redis的学习我做成了XMind树状图，点击详情查看</description>
    </item>
    
    <item>
      <title>用hugo搭建个人博客</title>
      <link>https://zhangxiaoshuai98.github.io/article/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 28 Jul 2020 18:10:14 +0900</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>真正的极客必然拥有自己的博客，hugo是一个用go语言编写的程序，搭建起来极为简单。</description>
    </item>
    
    <item>
      <title>SpringBoot2.X版本MySQL数据库问题</title>
      <link>https://zhangxiaoshuai98.github.io/article/springboot2.x%E7%89%88%E6%9C%ACmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 20 Jul 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/springboot2.x%E7%89%88%E6%9C%ACmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</guid>
      <description>MySQL驱动包6.0之后的配置有所变化，如果还是按照6.0以前的方式配置，就会出现错误。</description>
    </item>
    
    <item>
      <title>sprinboot-2.X快速上手3</title>
      <link>https://zhangxiaoshuai98.github.io/article/springbootlearn3/</link>
      <pubDate>Fri, 17 Jul 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/springbootlearn3/</guid>
      <description>本篇是springboot2.x快速上手的第三篇记录,GOGOGO！。</description>
    </item>
    
    <item>
      <title>sprinboot-2.X快速上手2</title>
      <link>https://zhangxiaoshuai98.github.io/article/springbootlearn2/</link>
      <pubDate>Mon, 13 Jul 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/springbootlearn2/</guid>
      <description>本篇是springboot2.x快速上手的第二篇记录，继续学习，继续前进。</description>
    </item>
    
    <item>
      <title>sprinboot-2.X快速上手1</title>
      <link>https://zhangxiaoshuai98.github.io/article/springbootlearn1/</link>
      <pubDate>Sun, 12 Jul 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/springbootlearn1/</guid>
      <description>初学springboot，我将会将我的学习过程以及想法记录在这个系列中，方便以后查看，也方便初学者学习。如果有不对的地方，欢迎指正。</description>
    </item>
    
    <item>
      <title>Mybatis源码分析</title>
      <link>https://zhangxiaoshuai98.github.io/article/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 07 Jun 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>Mybatis中的底层源码简单分析 简单执行过程梳理  调用了SqlSessionFactoryBuilder下builder()方法；
在这个方法中，首先创造了xMLConfigBuilder对象，其构造器中包含了创建configuration对象语句，但此时configuration对象中的成员还并没有被赋值。 执行xMLConfigBuilder对象中的parse()，此时全局配置被解析，所有xml解析的对象被放入configuration对象中。 将configuration传给DefaultSqlSessionFactory的构造器，返回一个DefaultSqlSessionFactory。到此，SqlSessionFactory构造完毕。 调用factory中的openSession()方法，在factory中利用config中的信息，将executor创建出来，和config一起传给DefaultSqlSession构造器，此时sqlSession对象成功创建。 调用sqlSession的getMapper()方法，其实底层调用的是config.getMapper，其又调用了mapperRegistry.getMapper。 在getMapper()方法中，利用mapperProxyFactory创建了mapperProxy代理对象，但它并不是最终的代理对象，他只是执行器 （实现了InvocationHandler，有invoke方法的对象），而真正的代理类是JDK中的对象Proxy.newProxyInstance动态创建（动态代理）。 执行代理类下的方法，其直接调用了mapperProxy(InvocationHandler)下的invoke()方法，经过跳转，其实际执行的是mapperProxy下的cachedInvoker。 最终执行SQL语句的，是StatementHandler，返回结果由ResultSetHandler处理。  </description>
    </item>
    
    <item>
      <title>Tomcat源码分析</title>
      <link>https://zhangxiaoshuai98.github.io/article/tomcat%E5%B1%82%E6%AC%A1/</link>
      <pubDate>Wed, 06 May 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/tomcat%E5%B1%82%E6%AC%A1/</guid>
      <description>Tomcat封装的非常好，以至于我们在使用中忽视了它的底层结构，在初步上手后，了解它的基本结构和运行原理是有必要的。</description>
    </item>
    
    <item>
      <title>协议问题踩坑</title>
      <link>https://zhangxiaoshuai98.github.io/article/%E5%8D%8F%E8%AE%AE%E9%94%99%E8%AF%AF/</link>
      <pubDate>Mon, 06 Jan 2020 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/%E5%8D%8F%E8%AE%AE%E9%94%99%E8%AF%AF/</guid>
      <description>协议错误  问题：
 在运行web项目时，出现了以下报错： Invalid character found in method name. HTTP method names must be tokens 一开始以为是浏览器编码问题，因为它提示是说请求方法名不对，查阅资料后发现，是因为url中，http写成了https，写了加密协议，所以自动对内容进行了加密，所以报错。
 解决：
 将utl地址协议改成http
  https：是由SSL证书技术加到http上形成的加密协议。</description>
    </item>
    
    <item>
      <title>HTML中form表entype三种属性</title>
      <link>https://zhangxiaoshuai98.github.io/article/html%E4%B8%ADform%E8%A1%A8entype%E4%B8%89%E7%A7%8D%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Fri, 15 Nov 2019 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/html%E4%B8%ADform%E8%A1%A8entype%E4%B8%89%E7%A7%8D%E5%B1%9E%E6%80%A7/</guid>
      <description>form表单中enctype属性的三种类型 form表单中enctype属性可以用来控制对表单数据的发送前的如何进行编码，enctype有三种，分别为：
  multipart/form-data不对字符编码，用于发送二进制的文件，其他两种类型不能用于发送文件；    text/plain用于发送纯文本内容，空格转换为 &amp;ldquo;+&amp;rdquo; 加号，不对特殊字符进行编码，一般用于email之类的；    application/x-www-form-urlencoded，在发送前会编码所有字符，即在发送到服务器之前，所有字符都会进行编码（空格转换为 &amp;ldquo;+&amp;rdquo; 加号，&amp;ldquo;+&amp;quot;加号转换为空格，特殊符号转换为 ASCII HEX 值）。   其中application/x-www-form-urlencoded为默认类型。
接收数据的方式   当定义enctype为multipart/form-data时(主要用于上传文件、视频等)，用以下方式接收  request.getInputStream();   当定义enctype为text/plain时，使用以下方式接收数据  request.getReader();   当定义enctype为application/x-www-form-urlencoded时，使用以下方式接收数据  request.getParameter(参数名);  </description>
    </item>
    
    <item>
      <title>Java集合总结</title>
      <link>https://zhangxiaoshuai98.github.io/article/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 11 Oct 2019 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</guid>
      <description>对于Java集合的学习，我做成了XMind，对于集合有时我们也叫容器。 </description>
    </item>
    
    <item>
      <title>Java的异常类关系梳理</title>
      <link>https://zhangxiaoshuai98.github.io/article/java%E5%BC%82%E5%B8%B8%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86/</link>
      <pubDate>Wed, 09 Oct 2019 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/java%E5%BC%82%E5%B8%B8%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86/</guid>
      <description>Error 错误是JVM发送错误，一般我们也没什么办法，所以我们不关注Error。
Exception 如图，Java中的异常分为运行时异常和非运行时异常。
RuntimeException 运行时异常就如同其名字，写代码时不会发现，只有运行程序的时候，才会出现，常见的如空指针NullPointerException、找不到类ClassNotFoundException、数组下标超出范围IndexOutOfBoundsException等。 解决：
 不管 捕获（try catch） 抛出（Throw）  CheckedException 非运行时异常（有时也叫可检查异常）是必须解决的，在编写代码时就会提示需要解决，否则无法编译。这种异常通常是程序员自己定义的。如IOException、SQLException（这两个是Java开发人员定义的）。 解决：
 捕获（try catch） 抛出（Throw）  </description>
    </item>
    
    <item>
      <title>Java的日期、时间类</title>
      <link>https://zhangxiaoshuai98.github.io/article/java%E7%9A%84%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB/</link>
      <pubDate>Tue, 08 Oct 2019 18:10:14 +0100</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/java%E7%9A%84%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB/</guid>
      <description>基础理解 在Java中，Date表示一个时间点，Calendar表示一个日期，而我们经常会将这两者来回转换。而更常见的是，用户输入字符串String，我们需要将它转化为Date存储。直接上图 图中我们可以轻易的看出：
 Date类是String和Calendar类的中间类 DateFormat是String和Date的中间类(接口)  </description>
    </item>
    
    <item>
      <title>字节码和机器码的概念</title>
      <link>https://zhangxiaoshuai98.github.io/article/%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E6%9C%BA%E5%99%A8%E7%A0%81%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sun, 06 Oct 2019 18:10:14 +0500</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E6%9C%BA%E5%99%A8%E7%A0%81%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>字节码和机器码的概念 本文主要说明在学习java时的体会和理解
  在编译时，jdk将我们的源码(也就是.java)转成字节码文件(.class)，字节码文件中包含了JVM能够识别的代码。 在运行时，JVM读取运行字节码文件，然后转化为机器码(只包含0和1)，进而让机器执行  </description>
    </item>
    
    <item>
      <title>&lt;? extends T&gt;与&lt;? super T&gt;</title>
      <link>https://zhangxiaoshuai98.github.io/article/extendst%E5%92%8Csupert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/extendst%E5%92%8Csupert/</guid>
      <description>简述 &amp;lt;? extends Orange &amp;gt;存放的可能是RedOrange,GoldenOrange 等等中的特定一种，所以在没掀开篮子遮布时，我无法确定篮子放的是具体哪种水果，所以无法进行存(add)操作（因为不知道要存哪种Orange）。但是，就算是闭着眼睛从篮子里拿出一个东西，我肯定知道拿出的是Orange（不管拿出来的是RedOrange ，GoldenOrange 还是什么，反正都是Orange），所以取(get）操作可行。 &amp;lt;? super Orange&amp;gt;存放的可能是Orange，Fruit中的特定一种。所以在没掀开篮子遮布时，我无法确定篮子放的是具体哪种水果，所以无法进行取(get)操作（有可能拿出来的是Orange，有可能是Fruit）。但是，只要是往里面存放Orange类型水果，那么是绝对是可以的（因为篮子里面的是Orange或者Fruit中特定水果，那么RedOrange和GolenOrange也是属于Orange和Fruit呀）。
总结 &amp;lt;? extends T&amp;gt;可以获取数据(get T类型)，无法存储数据(add)。 &amp;lt;? superT&amp;gt;可以存储数据(add T及T的子类)，无法获取数据(get)。 什么时候要使用&amp;lt;? extends T&amp;gt;,&amp;lt;? super T&amp;gt;呢，请记住下面这句话：
“如果你是希望调用T方法，那么使用&amp;lt;? extends T&amp;gt;，因为你可以进行取操作（get）。“ “如果你是希望往容器里面存数据，那么使用&amp;lt;? super T&amp;gt;。”</description>
    </item>
    
    <item>
      <title>抽象和接口的区别</title>
      <link>https://zhangxiaoshuai98.github.io/article/%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>java中抽象类和接口的区别 在java中，我们使用接口较多，而抽象类较少，所以导致我们常常分不清抽象类和接口的区别。其实只需要掌握三个方面，就可以完全明白他们的区别了，这三个方面分别是：成员变量、方法、构造器。
抽象类  成员变量 既可以是变量，也可以是常量 方法 既可以是普通方法也可以是抽象方法 构造器
可以有构造器，但不可以直接创造对象，是用来方便子类流通数据  接口  成员变量 只能是常量，默认被public static final修饰 方法 只能是抽象方法，默认被public abstract修饰 构造器 不可以有构造器   总结 接口相比抽象类更加抽象，所以我们有抽象需求时，一般都使用接口。</description>
    </item>
    
    <item>
      <title>类和类之间的关系总结</title>
      <link>https://zhangxiaoshuai98.github.io/article/%E7%B1%BB%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhangxiaoshuai98.github.io/article/%E7%B1%BB%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93/</guid>
      <description>类和类之间有一下几种关系  实现 继承 依赖 关联 聚合 组合   除了实现和继承，剩下四种关系都比较靠主观判断，只靠代码是不能区分的。 总体来说，关系强度：依赖&amp;lt;关联&amp;lt;聚合&amp;lt;组合 当然，根据迪米特原则，我们尽量要少让类和类之间产生关系 参考网址</description>
    </item>
    
  </channel>
</rss>